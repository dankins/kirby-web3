export interface EncryptedData {
  iv: string;
  cipherText: string;
}

export interface Persistence {
  // lookupKey is the generated by encrypting `username::password` using a hardcoded IV
  // iv is the initialization vector used to encrypt the cipherText (different for each user)
  // cipherText contains the encrypted `entropy` string
  storeAuthLookupKey(lookupKey: string, iv: string, cipherText: string): Promise<boolean>;
  // encrypt `username::password` using the hardcoded IV, and use that as a key
  // to locate the ciphertext containing the user's entropy / seed phrase
  getByAuthLookupKey(lookupKey: string): Promise<EncryptedData>;
  // createUser stores the username to prevent duplicate user accounts
  // otherwise the same username+password could be used with different ivs
  createUser(username: string): Promise<boolean>;
  // storeData is used to store a list of profiles so we can rehydrate them upon loading the wallet
  // if salt parameter is provided the key persisted will be hash(concat(key,salt))
  storeData(username: string, key: string, iv: string, cipherText: string, salt?: string): Promise<boolean>;
  // getData is used to store encrypted data by key
  // if the salt parameter is provided the lookup key queried will be hash(concat(key,salt))
  getData(username: string, key: string, salt?: string): Promise<EncryptedData>;

  storeEntropyLocal(username: string, entropy: string): void;
  getEntropyLocal(): { username: string; entropy: string } | undefined;
  clearLocalData(): void;
  isEphemeral(): boolean;
}
